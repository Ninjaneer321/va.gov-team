# .github/workflows/diversity-data-extraction.yml
#
# Purpose: Extract participant demographic data from research findings reports
# and aggregate for quarterly diversity reporting. Runs at the end of each quarter
# and tracks processed files to avoid duplication.
#
# Repository: va.gov-team (with sparse checkout)
# Reports pushed to: va.gov-research-repository/reports/quarterly-reports/diversity-reports/

name: Diversity Data Extraction

on: 
  push:
    paths:
      - 'products/**/research/**/*findings*.md'
      - 'teams/**/research/**/*findings*.md'
      - '!**/*.doc'
      - '!**/*.docx'
      - '!**/*.pptx'
      - '!**/*.pdf'
  schedule:
    # Run on first day after each quarter ends at 8:00 AM ET (13:00 UTC)
    # Q1 (Jan-Mar) report runs April 1
    # Q2 (Apr-Jun) report runs July 1
    # Q3 (Jul-Sep) report runs October 1
    # Q4 (Oct-Dec) report runs January 1
    - cron: '0 13 1 1,4,7,10 *'
  workflow_dispatch: 
    inputs:
      full_scan:
        description: 'Force reprocessing of all files (ignores processed manifest)'
        required: false
        default: 'false'
        type: boolean
      quarter:
        description: 'Specific quarter to process (e.g., 2026-Q1). Leave empty for auto-detect.'
        required: false
        default: ''
        type: string
      dry_run:
        description: 'Test run - do not push to research repository'
        required: false
        default: 'false'
        type: boolean

jobs:
  extract-diversity-data: 
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps: 
      - name: Sparse Checkout - Research Findings Only
        if: ${{ github.event.inputs.full_scan != 'true' }}
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            products/**/research
            teams/**/research
          sparse-checkout-cone-mode: false
          fetch-depth: 0  # Full history needed for file dates
      
      - name: Full Checkout
        if: ${{ github.event.inputs.full_scan == 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for file dates
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with: 
          node-version: '20'
      
      - name: Install dependencies
        run: |
          npm install js-yaml glob
      
      - name: Clone research repository for manifest
        env:
          GH_TOKEN: ${{ secrets.RESEARCH_REPO_TOKEN }}
        run: |
          git clone https://x-access-token:${GH_TOKEN}@github.com/department-of-veterans-affairs/va.gov-research-repository.git research-repo
          
          # Create directory structure if it doesn't exist
          mkdir -p research-repo/reports/quarterly-reports/diversity-reports
          
          # Create empty manifest if it doesn't exist
          if [ ! -f "research-repo/reports/quarterly-reports/diversity-reports/processed-files.json" ]; then
            echo '{"processed_files": [], "last_updated": null, "quarters_processed": []}' > research-repo/reports/quarterly-reports/diversity-reports/processed-files.json
          fi
      
      - name: Extract demographic data from findings
        id: extract
        uses: actions/github-script@v7
        with: 
          script: |
            const fs = require('fs');
            const path = require('path');
            const yaml = require('js-yaml');
            const globModule = require('glob');
            const { execSync } = require('child_process');
            
            // ============================================
            // CONFIGURATION AND HELPERS
            // ============================================
            
            // Helper function to safely parse integers
            const toInt = (value) => {
              const parsed = parseInt(value, 10);
              return isNaN(parsed) ? 0 : parsed;
            };
            
            // Helper function to encode file path for URLs
            const encodeFilePath = (filePath) => {
              return filePath.split('/').map(segment => encodeURIComponent(segment)).join('/');
            };
            
            // Helper function to check if a value is a placeholder/template value
            const isPlaceholder = (value) => {
              if (!value || typeof value !== 'string') return true;
              const placeholders = [
                'YYYY-MM-DD', 'yyyy-mm-dd', '[Study]', '[study]', '[Team]', '[team]',
                '[Product]', '[product]', 'TBD', 'tbd', 'N/A', 'n/a',
                'TODO', 'todo', 'PLACEHOLDER', 'placeholder'
              ];
              return placeholders.some(p => value.includes(p));
            };
            
            // Helper function to check if a key is valid (not numeric index or rate)
            const isValidDemographicKey = (key) => {
              if (/^\d+$/.test(key)) return false;
              if (key.endsWith('_rate')) return false;
              if (key === 'rate') return false;
              return true;
            };
            
            // Helper function to validate and parse date
            const parseDate = (dateStr) => {
              if (!dateStr || dateStr === 'unknown' || isPlaceholder(dateStr)) {
                return null;
              }
              const date = new Date(dateStr);
              if (!isNaN(date.getTime())) {
                return date;
              }
              const mmYyyyMatch = dateStr.match(/^(\d{1,2})-(\d{4})$/);
              if (mmYyyyMatch) {
                return new Date(`${mmYyyyMatch[2]}-${mmYyyyMatch[1].padStart(2, '0')}-01`);
              }
              return null;
            };
            
            // Helper function to format date for display
            const formatDate = (dateStr) => {
              const parsed = parseDate(dateStr);
              if (!parsed) return null;
              return parsed.toISOString().split('T')[0];
            };
            
            // Helper function to check if frontmatter has real data
            const hasCompletedData = (frontMatter) => {
              const hasValidDate = frontMatter.date && !isPlaceholder(frontMatter.date) && parseDate(frontMatter.date) !== null;
              const hasParticipants = toInt(frontMatter.participants_total) > 0;
              
              if (!hasValidDate && !hasParticipants) return false;
              
              if (frontMatter.title && isPlaceholder(frontMatter.title)) {
                return hasValidDate && hasParticipants;
              }
              
              return hasValidDate || hasParticipants;
            };
            
            // Helper to format label for display
            const formatLabel = (key) => {
              return key
                .replace(/_/g, ' ')
                .replace(/\b\w/g, c => c.toUpperCase())
                .replace(/^At /i, 'AT ')
                .replace(/ At /gi, ' AT ')
                .replace(/^Va /i, 'VA ')
                .replace(/ Va /gi, ' VA ');
            };
            
            // Helper to safely extract object data
            const safeExtractObject = (data) => {
              if (!data || typeof data !== 'object' || Array.isArray(data)) {
                return {};
              }
              const result = {};
              for (const [key, value] of Object.entries(data)) {
                if (isValidDemographicKey(key) && typeof value === 'number') {
                  result[key] = value;
                } else if (isValidDemographicKey(key) && typeof value === 'string') {
                  const numVal = toInt(value);
                  if (!isNaN(numVal)) {
                    result[key] = numVal;
                  }
                }
              }
              return result;
            };
            
            // ============================================
            // QUARTER CALCULATION
            // ============================================
            
            const getQuarterInfo = (inputQuarter) => {
              const now = new Date();
              let year, quarter, startDate, endDate;
              
              if (inputQuarter && /^\d{4}-Q[1-4]$/.test(inputQuarter)) {
                // Parse specified quarter (e.g., "2026-Q1")
                year = parseInt(inputQuarter.substring(0, 4));
                quarter = parseInt(inputQuarter.substring(6));
              } else {
                // Auto-detect: determine which quarter just ended
                // If running on Jan 1, we're reporting on Q4 of previous year
                // If running on Apr 1, we're reporting on Q1
                // If running on Jul 1, we're reporting on Q2
                // If running on Oct 1, we're reporting on Q3
                const month = now.getMonth(); // 0-indexed
                year = now.getFullYear();
                
                if (month >= 0 && month < 3) {
                  // January-March: report on Q4 of previous year
                  quarter = 4;
                  year = year - 1;
                } else if (month >= 3 && month < 6) {
                  // April-June: report on Q1
                  quarter = 1;
                } else if (month >= 6 && month < 9) {
                  // July-September: report on Q2
                  quarter = 2;
                } else {
                  // October-December: report on Q3
                  quarter = 3;
                }
              }
              
              // Calculate quarter date range
              const quarterStartMonths = { 1: 0, 2: 3, 3: 6, 4: 9 };
              startDate = new Date(year, quarterStartMonths[quarter], 1);
              endDate = new Date(year, quarterStartMonths[quarter] + 3, 0, 23, 59, 59, 999);
              
              return {
                year,
                quarter,
                label: `${year}-Q${quarter}`,
                startDate,
                endDate
              };
            };
            
            // Get file's last modified date from git
            const getFileModifiedDate = (filePath) => {
              try {
                const result = execSync(`git log -1 --format="%aI" -- "${filePath}"`, { encoding: 'utf8' }).trim();
                return result ? new Date(result) : null;
              } catch (err) {
                return null;
              }
            };
            
            // ============================================
            // MAIN PROCESSING
            // ============================================
            
            // Load inputs
            const fullScan = '${{ github.event.inputs.full_scan }}' === 'true';
            const inputQuarter = '${{ github.event.inputs.quarter }}' || '';
            const quarterInfo = getQuarterInfo(inputQuarter);
            
            console.log(`Processing quarter: ${quarterInfo.label}`);
            console.log(`Quarter range: ${quarterInfo.startDate.toISOString()} to ${quarterInfo.endDate.toISOString()}`);
            console.log(`Full scan mode: ${fullScan}`);
            
            // Load processed files manifest
            let manifest = { processed_files: [], last_updated: null, quarters_processed: [] };
            const manifestPath = 'research-repo/reports/quarterly-reports/diversity-reports/processed-files.json';
            
            try {
              const manifestContent = fs.readFileSync(manifestPath, 'utf8');
              manifest = JSON.parse(manifestContent);
            } catch (err) {
              console.log('No existing manifest found, starting fresh');
            }
            
            const isFirstRun = manifest.processed_files.length === 0;
            console.log(`First run (baseline): ${isFirstRun}`);
            
            // Find all findings files
            const files = await globModule.glob('**/research/**/*findings*.md', {
              ignore: ['node_modules/**', '.git/**', 'research-repo/**', '**/*.doc', '**/*.docx', '**/*.pptx', '**/*.pdf']
            });
            
            console.log(`Found ${files.length} total research findings files`);
            
            const allDemographics = [];
            const skippedFiles = [];
            const newlyProcessedFiles = [];
            const errors = [];
            
            const repoOwner = 'department-of-veterans-affairs';
            const repoName = 'va.gov-team';
            const defaultBranch = 'master';
            
            for (const file of files) {
              try {
                // Check if file was already processed (unless full scan or first run)
                if (!fullScan && !isFirstRun && manifest.processed_files.includes(file)) {
                  skippedFiles.push({ file, reason: 'Already processed in previous quarter' });
                  continue;
                }
                
                // Check file modification date (hybrid approach)
                const fileModDate = getFileModifiedDate(file);
                
                // For non-first runs, check if file was modified within the quarter
                if (!fullScan && !isFirstRun && fileModDate) {
                  if (fileModDate < quarterInfo.startDate || fileModDate > quarterInfo.endDate) {
                    // File wasn't modified this quarter and wasn't in manifest
                    // This means it's a new file from a previous quarter - skip it
                    if (fileModDate < quarterInfo.startDate) {
                      skippedFiles.push({ file, reason: 'File predates current quarter and not previously processed' });
                      continue;
                    }
                  }
                }
                
                const content = fs.readFileSync(file, 'utf8');
                
                // Extract YAML front matter
                const yamlMatch = content.match(/^---\n([\s\S]*?)\n---/);
                if (!yamlMatch) {
                  continue;
                }
                
                const frontMatter = yaml.load(yamlMatch[1]);
                
                if (frontMatter.demographics || frontMatter.participants_total) {
                  
                  if (!hasCompletedData(frontMatter)) {
                    skippedFiles.push({ file, reason: 'Incomplete or template frontmatter' });
                    continue;
                  }
                  
                  const encodedPath = encodeFilePath(file);
                  const fileUrl = `https://github.com/${repoOwner}/${repoName}/blob/${defaultBranch}/${encodedPath}`;
                  
                  let title = frontMatter.title || '';
                  if (!title || isPlaceholder(title)) {
                    const pathParts = file.split('/');
                    const fileName = pathParts.pop().replace('.md', '').replace(/-/g, ' ');
                    const folderName = pathParts.pop() || '';
                    title = folderName.replace(/-/g, ' ').replace(/^\d{4}-\d{2}\s*/, '') || fileName;
                    title = title.replace(/\b\w/g, c => c.toUpperCase());
                  }
                  
                  const record = {
                    file: file,
                    file_url: fileUrl,
                    file_modified: fileModDate ? fileModDate.toISOString() : null,
                    date: frontMatter.date || 'unknown',
                    date_parsed: parseDate(frontMatter.date),
                    date_formatted: formatDate(frontMatter.date),
                    product: frontMatter.product || 'unknown',
                    team: frontMatter.team || 'unknown',
                    title: title,
                    participants_total: toInt(frontMatter.participants_total),
                    demographics: frontMatter.demographics || {},
                    devices_used: frontMatter.devices_used || {},
                    methodology: frontMatter.methodology || []
                  };
                  
                  allDemographics.push(record);
                  newlyProcessedFiles.push(file);
                }
              } catch (err) {
                errors.push({ file, error: err.message });
              }
            }
            
            console.log(`Extracted demographics from ${allDemographics.length} files`);
            console.log(`Newly processed files: ${newlyProcessedFiles.length}`);
            console.log(`Skipped files: ${skippedFiles.length}`);
            console.log(`Errors: ${errors.length}`);
            
            // ============================================
            // AGGREGATION
            // ============================================
            
            const aggregated = {
              extraction_date: new Date().toISOString(),
              quarter: quarterInfo.label,
              quarter_start: quarterInfo.startDate.toISOString(),
              quarter_end: quarterInfo.endDate.toISOString(),
              is_baseline: isFirstRun,
              total_studies: allDemographics.length,
              total_participants: 0,
              
              participant_types: {
                veterans: 0,
                service_members: 0,
                caregivers: 0,
                dependents: 0,
                VA_staff: 0
              },
              
              devices: {
                desktop: 0,
                tablet: 0,
                smartphone: 0,
                assistive_technology: 0
              },
              
              age: {
                '25-34': 0,
                '35-44': 0,
                '45-54': 0,
                '55-64': 0,
                '65+': 0,
                'unknown': 0
              },
              
              education: {
                high_school: 0,
                some_college: 0,
                associates: 0,
                bachelors: 0,
                masters: 0,
                doctorate: 0,
                unknown: 0
              },
              
              location: {
                urban: 0,
                rural: 0,
                unknown: 0
              },
              
              race: {
                white: 0,
                black: 0,
                hispanic: 0,
                biracial: 0,
                asian: 0,
                native: 0
              },
              
              disability: {
                cognitive: 0,
                AT_beginner: 0,
                AT_advanced: 0,
                screen_reader_desktop: 0,
                screen_reader_mobile: 0,
                magnification_zoom: 0,
                speech_input: 0,
                hearing_aids: 0,
                sighted_keyboard: 0,
                captions: 0
              },
              
              at_inclusion: {
                studies_with_at: 0,
                total_at_participants: 0
              },
              
              studies: allDemographics.map(r => ({
                title: r.title,
                file: r.file,
                url: r.file_url,
                date: r.date_formatted || r.date,
                product: r.product,
                team: r.team,
                participants: r.participants_total
              })),
              
              skipped_files: skippedFiles,
              newly_processed_files: newlyProcessedFiles
            };
            
            // Aggregate all data
            for (const record of allDemographics) {
              aggregated.total_participants += toInt(record.participants_total);
              
              for (const type of ['veterans', 'service_members', 'caregivers', 'dependents', 'VA_staff']) {
                if (record.demographics?.[type] !== undefined) {
                  aggregated.participant_types[type] += toInt(record.demographics[type]);
                }
              }
              
              const deviceData = safeExtractObject(record.devices_used);
              for (const device of ['desktop', 'tablet', 'smartphone', 'assistive_technology']) {
                if (deviceData[device] !== undefined) {
                  aggregated.devices[device] += toInt(deviceData[device]);
                }
              }
              
              const atCount = toInt(deviceData.assistive_technology || 0);
              if (atCount > 0) {
                aggregated.at_inclusion.studies_with_at++;
                aggregated.at_inclusion.total_at_participants += atCount;
              }
              
              const ageData = safeExtractObject(record.demographics?.age);
              for (const [key, value] of Object.entries(ageData)) {
                if (aggregated.age.hasOwnProperty(key)) {
                  aggregated.age[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.age[key] = toInt(value);
                }
              }
              
              const educationData = safeExtractObject(record.demographics?.education);
              for (const [key, value] of Object.entries(educationData)) {
                if (aggregated.education.hasOwnProperty(key)) {
                  aggregated.education[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.education[key] = toInt(value);
                }
              }
              
              const locationData = safeExtractObject(record.demographics?.location);
              for (const [key, value] of Object.entries(locationData)) {
                if (aggregated.location.hasOwnProperty(key)) {
                  aggregated.location[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.location[key] = toInt(value);
                }
              }
              
              const raceData = safeExtractObject(record.demographics?.race);
              for (const [key, value] of Object.entries(raceData)) {
                if (aggregated.race.hasOwnProperty(key)) {
                  aggregated.race[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.race[key] = toInt(value);
                }
              }
              
              const disabilityData = safeExtractObject(record.demographics?.disability);
              for (const [key, value] of Object.entries(disabilityData)) {
                if (aggregated.disability.hasOwnProperty(key)) {
                  aggregated.disability[key] += toInt(value);
                } else if (isValidDemographicKey(key)) {
                  aggregated.disability[key] = toInt(value);
                }
              }
            }
            
            // Calculate rates
            let atInclusionRate = '0.0%';
            if (aggregated.total_studies > 0) {
              atInclusionRate = (
                (aggregated.at_inclusion.studies_with_at / aggregated.total_studies) * 100
              ).toFixed(1) + '%';
            }
            
            const locationTotal = aggregated.location.rural + aggregated.location.urban;
            
            // ============================================
            // UPDATE MANIFEST
            // ============================================
            
            // Add newly processed files to manifest
            const updatedProcessedFiles = [...new Set([...manifest.processed_files, ...newlyProcessedFiles])];
            const updatedQuarters = [...new Set([...manifest.quarters_processed, quarterInfo.label])];
            
            const updatedManifest = {
              processed_files: updatedProcessedFiles,
              last_updated: new Date().toISOString(),
              quarters_processed: updatedQuarters.sort(),
              last_quarter: quarterInfo.label,
              total_files_processed: updatedProcessedFiles.length
            };
            
            fs.writeFileSync(manifestPath, JSON.stringify(updatedManifest, null, 2));
            console.log(`Updated manifest with ${newlyProcessedFiles.length} new files`);
            
            // ============================================
            // GENERATE SUMMARY
            // ============================================
            
            core.setOutput('aggregated', JSON.stringify(aggregated, null, 2));
            core.setOutput('study_count', allDemographics.length);
            core.setOutput('participant_count', aggregated.total_participants);
            core.setOutput('skipped_count', skippedFiles.length);
            core.setOutput('quarter_label', quarterInfo.label);
            
            const summaryLines = [
              '# Diversity Data Extraction Summary',
              '',
              `**Quarter:** ${quarterInfo.label}`,
              `**Quarter Period:** ${quarterInfo.startDate.toISOString().split('T')[0]} to ${quarterInfo.endDate.toISOString().split('T')[0]}`,
              `**Extraction Date:** ${aggregated.extraction_date}`,
              isFirstRun ? '**Note:** This is the baseline report including all historical data.' : '',
              '',
              '## Overview',
              '- **Total Studies:** ' + aggregated.total_studies,
              '- **Total Participants:** ' + aggregated.total_participants,
              '- **New Files Processed:** ' + newlyProcessedFiles.length,
              '- **Files Skipped:** ' + skippedFiles.length,
              '',
              '---',
              '',
              '## Participant Types',
              ''
            ];
            
            for (const [key, value] of Object.entries(aggregated.participant_types)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            summaryLines.push('## Devices Used', '');
            for (const [key, value] of Object.entries(aggregated.devices)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            summaryLines.push('## Assistive Technology Inclusion', '');
            summaryLines.push(`- **Studies with AT Users:** ${aggregated.at_inclusion.studies_with_at} (${atInclusionRate})`);
            summaryLines.push(`- **Total AT Participants:** ${aggregated.at_inclusion.total_at_participants}`);
            summaryLines.push('');
            
            summaryLines.push('## Age Distribution', '');
            for (const [key, value] of Object.entries(aggregated.age)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${key}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            summaryLines.push('## Education Levels', '');
            for (const [key, value] of Object.entries(aggregated.education)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            summaryLines.push('## Geographic Location', '');
            for (const [key, value] of Object.entries(aggregated.location)) {
              if (isValidDemographicKey(key)) {
                let rateStr = '';
                if ((key === 'rural' || key === 'urban') && locationTotal > 0) {
                  const rate = ((value / locationTotal) * 100).toFixed(1);
                  rateStr = ` (${rate}%)`;
                }
                summaryLines.push(`- **${formatLabel(key)}:** ${value}${rateStr}`);
              }
            }
            summaryLines.push('');
            
            summaryLines.push('## Race/Ethnicity', '');
            for (const [key, value] of Object.entries(aggregated.race)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            summaryLines.push('## Disability & Assistive Technology Details', '');
            for (const [key, value] of Object.entries(aggregated.disability)) {
              if (isValidDemographicKey(key)) {
                summaryLines.push(`- **${formatLabel(key)}:** ${value}`);
              }
            }
            summaryLines.push('');
            
            summaryLines.push('---', '');
            summaryLines.push('## Appendix: Studies Included in This Report', '');
            
            const sortedStudies = [...allDemographics].sort((a, b) => {
              if (!a.date_parsed && !b.date_parsed) return 0;
              if (!a.date_parsed) return 1;
              if (!b.date_parsed) return -1;
              return b.date_parsed - a.date_parsed;
            });
            
            for (const study of sortedStudies) {
              const dateStr = study.date_formatted ? ` (${study.date_formatted})` : '';
              const participantStr = study.participants_total > 0 ? ` - ${study.participants_total} participants` : '';
              summaryLines.push(`- [${study.title}](${study.file_url})${dateStr}${participantStr}`);
            }
            
            const summary = summaryLines.join('\n');
            
            // Write files with quarter-based naming
            fs.writeFileSync(`diversity-summary-${quarterInfo.label}.md`, summary);
            fs.writeFileSync(`diversity-data-${quarterInfo.label}.json`, JSON.stringify(aggregated, null, 2));
            
            // Also write generic names for artifact upload
            fs.writeFileSync('diversity-summary.md', summary);
            fs.writeFileSync('diversity-data.json', JSON.stringify(aggregated, null, 2));
      
      - name: Upload diversity data artifact
        uses: actions/upload-artifact@v4
        with: 
          name: diversity-data-${{ steps.extract.outputs.quarter_label }}
          path: |
            diversity-summary.md
            diversity-data.json
          retention-days: 90
      
      - name: Push reports to va.gov-research-repository
        if: ${{ github.event.inputs.dry_run != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.RESEARCH_REPO_TOKEN }}
        run: |
          cd research-repo
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          QUARTER_LABEL="${{ steps.extract.outputs.quarter_label }}"
          
          # Copy the generated reports with quarter-based names
          cp "../diversity-summary-${QUARTER_LABEL}.md" "reports/quarterly-reports/diversity-reports/diversity-summary-${QUARTER_LABEL}.md"
          cp "../diversity-data-${QUARTER_LABEL}.json" "reports/quarterly-reports/diversity-reports/diversity-data-${QUARTER_LABEL}.json"
          
          # Also maintain a "latest" copy for easy access
          cp "../diversity-summary-${QUARTER_LABEL}.md" "reports/quarterly-reports/diversity-reports/diversity-summary-latest.md"
          cp "../diversity-data-${QUARTER_LABEL}.json" "reports/quarterly-reports/diversity-reports/diversity-data-latest.json"
          
          # Create/update the reports README if it doesn't exist
          if [ ! -f "reports/quarterly-reports/diversity-reports/README.md" ]; then
            cat > reports/quarterly-reports/diversity-reports/README.md << 'EOF'
          # Diversity Reports

          This folder contains automatically generated quarterly diversity data reports from research findings.

          ## Report Files

          - `diversity-summary-latest.md` - Most recent quarterly summary report
          - `diversity-data-latest.json` - Most recent data in JSON format
          - `processed-files.json` - Manifest tracking all processed research files
          - Quarter-specific reports (e.g., `diversity-summary-2026-Q1.md`) are retained for historical tracking

          ## Data Source

          These reports are automatically generated from research findings in the va.gov-team repository.
          They aggregate participant demographic data for quarterly diversity reporting.

          ## Update Schedule

          Reports are generated quarterly:
          - Q1 (Jan-Mar) report runs on April 1
          - Q2 (Apr-Jun) report runs on July 1
          - Q3 (Jul-Sep) report runs on October 1
          - Q4 (Oct-Dec) report runs on January 1

          ## File Tracking

          The workflow maintains a manifest (`processed-files.json`) to track which research files have been
          processed. This ensures each study is only counted once and prevents duplication across quarters.
          EOF
          fi
          
          # Check if there are changes to commit
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git add reports/
            git commit -m "Update diversity data reports - ${QUARTER_LABEL}

          Quarterly diversity data extraction from va.gov-team research findings.
          
          Quarter: ${QUARTER_LABEL}
          Studies analyzed: ${{ steps.extract.outputs.study_count }}
          Total participants: ${{ steps.extract.outputs.participant_count }}
          Files skipped: ${{ steps.extract.outputs.skipped_count }}
          
          Generated by: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            
            git push
            echo "Reports pushed successfully to va.gov-research-repository"
          fi
      
      - name: Dry run notice
        if: ${{ github.event.inputs.dry_run == 'true' }}
        run: |
          echo "::notice::DRY RUN - Reports were generated but NOT pushed to va.gov-research-repository"
          echo "## ðŸ§ª Dry Run Mode" >> $GITHUB_STEP_SUMMARY
          echo "Reports were generated and uploaded as artifacts but **not pushed** to va.gov-research-repository." >> $GITHUB_STEP_SUMMARY
          echo "Quarter: ${{ steps.extract.outputs.quarter_label }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
      
      - name: Post summary
        run: |
          cat diversity-summary.md >> $GITHUB_STEP_SUMMARY
